---
title: "Manipulating Data Frames"
output:
  word_document: default
  html_notebook: default
---

```{r message=FALSE, warning=FALSE}
# As usual, we load the mosaic and tidyverse packages.
# Loading tidyverse automatically loads the dplyr package, which is
# the package that provides many of the operations illustrated here.
library(mosaic)
library(tidyverse)
```
```{r message=FALSE, warning=FALSE}
# We make use of the run09 data frame, which is included in the
# cherryblossom package.
library(cherryblossom)
head(run09)
```
```{r}
# Selecting Columns.
# To select certain columns from a data frame, we use the select()
# operation.  Here, we select the net_time, age, gender, last, state,
# country, and div columns from run09, assigning the resulting data
# frame to data01.
data01 <- select(run09, net_time, age, gender, last,
                 state, country, div)
head(data01)
```
```{r}
# The columns are ordered in the order they are listed in the
# select() command.  Let's do it again, putting the columns in
# a different order, and renaming the net_time column.
# Also, most data scientists prefer to use the "piping" operator,
# %>%.
data02 <- run09 %>%
  select(last, gender, age, time = net_time, 
         state, country, div)
head(data02)
```
```{r}
# Read the above as code follows: Take the run09 data frame,
# and pipe it through the select operation; then assign the
# result to data02.
#
# Selecting Rows.
# To select the rows from a data frame that satisfy certain
# criteria, we use the filter() operation.  Let's "filter in"
# the rows of data02 corresponding to male runners from the USA.
# Again, we use piping.
data03 <- data02 %>%
  filter(gender == "M" & country == "USA")
head(data03)
```
```{r}
# The View() command can be used to look at a data frame in a separate
# tab.  After executing the command, it is recommended that it be
# commented out, so that it doesn't "mess" with knitting.
# View(data03)
```
```{r}
# Note that there is at least one row where state = "NR", which
# I'm guessing means that runner failed to provide his state.  So,
# let's filter out any such rows; also, we no longer need country
# and gender, so let's select the other columns.
data04 <- data03 %>%
  filter(state != "NR") %>%
  select(!(country|gender))
head(data04)
  
```
```{r}
# Modifying/Adding Columns.
# The mutate() operation can be used to modify an existing column,
# or to add columns.  The type of the variable last should not (in
# my opinion) be "factor" - think of factor as indicating that the
# value could be chosen from a drop-down menu.  For example, it
# makes sense for the gender and state variables to be of type
# factor.  Rather, the type of last should be "character".  Let's
# apply mutate() and the as.character() operation to fix this.
data05 <- data04 %>%
  mutate(last = as.character(last))
head(data05)
```
```{r}
# Let's add a new column, adj_time (adjusted time), defined as
# follows: adj_time = time - age.
data06 <- data05 %>%
  mutate(adj_time = time - age)
head(data06)
```
```{r}
# Renaming Columns.
# The rename() operation can be used to rename a column.  Let's
# rename "last" as "last_name".  Note: This could have been done
# above as part of selection/mutation.
data07 <- data06 %>%
  rename(last_name = last)
head(data07)
```
```{r}
# Ordering Rows.
# The arrange() operation can be used to order the rows according to
# the values in one (or more) columns.  Here, we arrange the rows in
# order of increasing time, and then we arrange the rows in order of
# decreasing age.
data08 <- data07 %>%
  arrange(time)
head(data08)
```
```{r}
data09 <- data07 %>%
  arrange(desc(age))
head(data09)
```
```{r message=FALSE, warning=FALSE}
# Aggregating Rows: group_by() and summarize().
# Example: Produce a data frame that gives the number of runners
# in, and the minimum time, for each division.
data10 <- data09 %>%
  group_by(div) %>%
  summarize(number = n(), min_time = min(time))
data10
```
```{r message=FALSE, warning=FALSE}
# Apparently, the time is missing for at least one runner in
# division 6.  Let's filter out any such rows from data09, and
# then try again.
data09alt <- data09 %>%
  filter(time != "NA")
data10alt <- data09alt %>%
  group_by(div) %>%
  summarize(number = n(), min_time = min(time))
data10alt
```
```{r message=FALSE, warning=FALSE}
# Bingo!
# Another Example: The state with the best average adjusted time
# receives a trophy.  To qualify, the state must have at least 10
# runners.
data11 <- data09alt %>%
  group_by(state) %>%
  summarize(number = n(), mean_adj_time = mean(adj_time)) %>%
  filter(number > 9) %>%
  arrange(mean_adj_time)
head(data11,10)
```
```{r}
# And the winner is ... New Hampshire!
# Note that they had just enough runners to qualify.
#
# Joining Data Frames Over a Common Column
# There are several versions of the join operation. To illustrate
# them, let's build a couple of small data frames.
init <- c("AA","BB","CC","DD","EE")
id <- c("BB","CC","DD","EE","FF")
var1 <- seq(11,19,2)
var2 <- seq(21,33,3)
df1 <- tibble(init,var1)
df1

```
```{r}
df2 <- tibble(id,var2)
df2
```
```{r}
# Using inner_join() to join df1 with df2.
join1 <- df1 %>%
  inner_join(df2, by = c("init" = "id"))
join1
```
```{r}
# Using inner_join() to join df2 with df1.
join2 <- df2 %>%
  inner_join(df1, by = c("id" = "init"))
join2
```
```{r}
# Note that the inner_join() operation is essentially
# "commutative" - except for the order of the columns in the
# result.  That is, we get essentially the same result whether
# we inner_join df1 with df2 or df2 with df1.
# Also note that we get only those ids/inits that are common to
# both data frames.
# Contrast this with the results produced by left_join().
join3 <- df1 %>%
  left_join(df2, by = c("init" = "id"))
join3
```
```{r}
# Note that we get all the information from df1, and the
# values for var2 are added where defined.
# Let's try it the other way.
join4 <- df2 %>%
  left_join(df1, by = c("id" = "init"))
join4
```
```{r}
# Here, we get all the information from df2, with the values
# for var1 added where defined.
# In short, the left_join operation is not commutative.
```

